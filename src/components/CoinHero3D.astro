---
// CoinHero3D — exact port of coffer2-ui coin-viewer-3d, single coin, non-interactive
// Set data-metal="gold" or data-metal="silver" on #coin-3d-hero to switch
---

<script>
import * as THREE from 'three';

function init() {
  const container = document.getElementById('coin-3d-hero');
  if (!container) return;

  // ── Coin pairs: add new {obverse, reverse, metal} entries here ──
  const COIN_PAIRS = [
    { obverse: 'obverse.jpg', reverse: 'reverse.jpg', metal: 'silver' },
    //{ obverse: 'obverse-2.jpg', reverse: 'reverse-2.jpg', metal: 'gold' },
    //{ obverse: 'obverse-3.jpg', reverse: 'reverse-3.jpg', metal: 'silver' },
  ];

  // ── Pick a random pair on each page load ──
  const coin = COIN_PAIRS[Math.floor(Math.random() * COIN_PAIRS.length)];

  // ── Configuration ──
  const isGold = coin.metal === 'gold';
  const METAL_COLOR = isGold ? 0xe8d8b0 : 0xffffff; // coffer2-ui: getMetalColor()
  container.dataset.metal = coin.metal;

  // ── Scene (no background → transparent) ──
  const scene = new THREE.Scene();

  // ── Camera (coffer2-ui large: z = 4.5, pulled closer for bigger coin) ──
  const w = container.clientWidth || 440;
  const h = container.clientHeight || 400;
  const camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
  camera.position.z = 4.0;

  // ── Renderer ──
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(w, h);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  container.appendChild(renderer.domElement);

  // ── Lighting (identical to coffer2-ui lines 213-225) ──
  scene.add(new THREE.AmbientLight(0xffffff, 1.5));

  const keyLight = new THREE.DirectionalLight(0xffffff, 1.8);
  keyLight.position.set(5, 5, 5);
  scene.add(keyLight);

  const fillLight = new THREE.DirectionalLight(0x8899aa, 1.3);
  fillLight.position.set(-5, 0, -5);
  scene.add(fillLight);

  const rimLight = new THREE.DirectionalLight(0xffffff, 1.2);
  rimLight.position.set(0, -5, 0);
  scene.add(rimLight);

  // ── Coin group ──
  const coinGroup = new THREE.Group();
  scene.add(coinGroup);

  // ── Texture loader ──
  const textureLoader = new THREE.TextureLoader();
  const base = import.meta.env.BASE_URL.replace(/\/+$/, '');
  const basePath = `${base}/coins`;

  function loadTexture(url: string): Promise<THREE.Texture> {
    return new Promise((resolve) => {
      textureLoader.load(
        url,
        (texture) => {
          texture.wrapS = THREE.ClampToEdgeWrapping;
          texture.wrapT = THREE.ClampToEdgeWrapping;
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.center.set(0.5, 0.5);
          resolve(texture);
        },
        undefined,
        () => resolve(createDefaultTexture()),
      );
    });
  }

  function createDefaultTexture(): THREE.Texture {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d')!;
    const grad = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
    grad.addColorStop(0, '#d8d8d8');
    grad.addColorStop(0.5, '#c0c0c0');
    grad.addColorStop(1, '#a0a0a0');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(256, 256, 256, 0, Math.PI * 2);
    ctx.fill();
    return new THREE.CanvasTexture(canvas);
  }

  // ── Build coin (coffer2-ui "large": radius 1.4, thickness 0.1, 128 segments) ──
  const radius = 1.4;
  const thickness = 0.1;
  const segments = 128;

  Promise.all([
    loadTexture(`${basePath}/${coin.obverse}`),
    loadTexture(`${basePath}/${coin.reverse}`),
  ]).then(([frontTex, backTex]) => {
    // edge (coffer2-ui: createEdgeMaterial — metalness 0.99, roughness 0.2)
    const edgeGeo = new THREE.CylinderGeometry(radius, radius, thickness, segments);
    edgeGeo.rotateX(Math.PI / 2);
    const edge = new THREE.Mesh(
      edgeGeo,
      new THREE.MeshStandardMaterial({
        color: METAL_COLOR,
        metalness: 0.99,
        roughness: 0.2,
      }),
    );

    // front face — obverse (coffer2-ui: createCoinMaterial — metalness 0.95, roughness 0.3)
    const frontGeo = new THREE.CircleGeometry(radius * 0.99, segments);
    const front = new THREE.Mesh(
      frontGeo,
      new THREE.MeshStandardMaterial({
        map: frontTex,
        color: METAL_COLOR,
        metalness: 0.95,
        roughness: 0.3,
      }),
    );
    front.position.z = thickness / 2 + 0.001;

    // back face — reverse
    const backGeo = new THREE.CircleGeometry(radius * 0.99, segments);
    const back = new THREE.Mesh(
      backGeo,
      new THREE.MeshStandardMaterial({
        map: backTex,
        color: METAL_COLOR,
        metalness: 0.95,
        roughness: 0.3,
      }),
    );
    back.position.z = -thickness / 2 - 0.001;
    back.rotation.y = Math.PI;

    const coinMesh = new THREE.Group();
    coinMesh.add(edge, front, back);
    coinGroup.add(coinMesh);

    // ── Animation (delta-time based, frame-rate independent) ──
    // Original values tuned for 60 fps: targetRotY += 0.004/frame, easing 0.08/frame
    const ROTATION_SPEED = 0.24; // rad/s (0.004 * 60)
    const EASE_BASE = 0.08; // per-frame factor at 60 fps
    let targetRotY = 0;
    const baseY = coinGroup.position.y;
    let lastTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const delta = Math.min((now - lastTime) / 1000, 0.1); // seconds, capped to avoid jumps
      lastTime = now;

      targetRotY += ROTATION_SPEED * delta;
      // frame-rate-independent exponential easing: 1 - (1-base)^(delta*60)
      const easeFactor = 1 - Math.pow(1 - EASE_BASE, delta * 60);
      coinGroup.rotation.y += (targetRotY - coinGroup.rotation.y) * easeFactor;

      // gentle vertical hover (already time-based via performance.now)
      coinGroup.position.y = baseY + Math.sin(now * 0.001) * 0.03;

      renderer.render(scene, camera);
    }

    animate();
  });

  // ── Responsive resize ──
  new ResizeObserver(() => {
    const rw = container.clientWidth;
    const rh = container.clientHeight;
    if (rw > 0 && rh > 0) {
      camera.aspect = rw / rh;
      camera.updateProjectionMatrix();
      renderer.setSize(rw, rh);
    }
  }).observe(container);
}

init();
</script>
